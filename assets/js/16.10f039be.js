(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{370:function(t,a,s){"use strict";s.r(a);var e=s(44),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"position-属性的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#position-属性的作用"}},[t._v("#")]),t._v(" position 属性的作用")]),t._v(" "),s("p",[t._v("position属性用来指定一个元素在网页上的位置，一共有5种定位方式，即position属性主要有五个值。")]),t._v(" "),s("ul",[s("li",[t._v("static")]),t._v(" "),s("li",[t._v("relative")]),t._v(" "),s("li",[t._v("fixed")]),t._v(" "),s("li",[t._v("absolute")]),t._v(" "),s("li",[t._v("sticky")])]),t._v(" "),s("h2",{attrs:{id:"static-属性值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#static-属性值"}},[t._v("#")]),t._v(" static 属性值")]),t._v(" "),s("p",[t._v("static是position属性的默认值。如果省略position属性，浏览器就认为该元素是static定位。")]),t._v(" "),s("p",[t._v('这时，浏览器会按照源码的顺序，决定每个元素的位置，这称为"正常的页面流"（normal flow）。每个块级元素占据自己的区块（block），元素与元素之间不产生重叠，这个位置就是元素的默认位置。\n注意，static定位所导致的元素位置，是浏览器自主决定的，所以这时top、bottom、left、right这四个属性无效')]),t._v(" "),s("h2",{attrs:{id:"relative-absolute-fixed"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#relative-absolute-fixed"}},[t._v("#")]),t._v(" relative，absolute，fixed")]),t._v(" "),s("p",[t._v("relative、absolute、fixed这三个属性值有一个共同点，都是相对于某个基点的定位，不同之处仅仅在于基点不同。所以，只要理解了它们的基点是什么，就很容易掌握这三个属性值。")]),t._v(" "),s("h3",{attrs:{id:"relative-属性值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#relative-属性值"}},[t._v("#")]),t._v(" relative 属性值")]),t._v(" "),s("p",[t._v("relative表示，相对于默认位置（即static时的位置）进行偏移，即定位基点是元素的默认位置。\n它必须搭配top、bottom、left、right这四个属性一起使用，用来指定偏移的方向和距离。")]),t._v(" "),s("h3",{attrs:{id:"absolute-属性值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#absolute-属性值"}},[t._v("#")]),t._v(" absolute 属性值")]),t._v(" "),s("p",[t._v("absolute表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。\n它有一个重要的限制条件：定位基点（一般是父元素）不能是static定位，否则定位基点就会变成整个网页的根元素html。另外，absolute定位也必须搭配top、bottom、left、right这四个属性一起使用")]),t._v(" "),s("p",[t._v('注意，absolute定位的元素会被"正常页面流"忽略，即在"正常页面流"中，该元素所占空间为零，周边元素不受影响。')]),t._v(" "),s("h3",{attrs:{id:"fixed-属性值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fixed-属性值"}},[t._v("#")]),t._v(" fixed 属性值")]),t._v(" "),s("p",[t._v("fixed表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口。这会导致元素的位置不随页面滚动而变化，好像固定在网页上一样。\n它如果搭配top、bottom、left、right这四个属性一起使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。")]),t._v(" "),s("h3",{attrs:{id:"sticky-属性值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sticky-属性值"}},[t._v("#")]),t._v(" sticky 属性值")]),t._v(" "),s("p",[t._v("sticky跟前面四个属性值都不一样，它会产生动态效果，很像relative和fixed的结合：一些时候是relative定位（定位基点是自身默认位置），另一些时候自动变成fixed定位（定位基点是视口）。")]),t._v(" "),s("p",[t._v('因此，它能够形成"动态固定"的效果。比如，网页的搜索工具栏，初始加载时在自己的默认位置（relative定位）。')]),t._v(" "),s("p",[t._v('sticky生效的前提是，必须搭配top、bottom、left、right这四个属性一起使用，不能省略，否则等同于relative定位，不产生"动态固定"的效果。原因是这四个属性用来定义"偏移距离"，浏览器把它当作sticky的生效门槛。')]),t._v(" "),s("p",[t._v("它的具体规则是，当页面滚动，父元素开始脱离视口时（即部分不可见），只要与sticky元素的距离达到生效门槛，relative定位自动切换为fixed定位；等到父元素完全脱离视口时（即完全不可见），fixed定位自动切换回relative定位。")]),t._v(" "),s("p",[t._v("请看下面的示例代码。（注意，除了已被淘汰的 IE 以外，其他浏览器目前都支持sticky。但是，Safari 浏览器需要加上浏览器前缀-webkit-。）")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("    #toolbar "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        position"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("webkit"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("sticky"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* safari 浏览器 */")]),t._v("\n        position"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" sticky"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 其他浏览器 */")]),t._v("\n        top"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v("px"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("上面代码中，页面向下滚动时，#toolbar的父元素开始脱离视口，一旦视口的顶部与#toolbar的距离小于20px（门槛值），#toolbar就自动变为fixed定位，保持与视口顶部20px的距离。页面继续向下滚动，父元素彻底离开视口（即整个父元素完全不可见），#toolbar恢复成relative定位。")])])}),[],!1,null,null,null);a.default=r.exports}}]);